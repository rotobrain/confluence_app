'''Convert Confluence Wiki space to HTML 5 App'''
# -*- coding: utf-8 -*-

from argparse import ArgumentParser
from glob import iglob
from string import Template
from os import listdir
from os.path import basename, getctime, isdir, isfile, join, islink
from shutil import copy, copytree, rmtree
from time import strftime

import boto.s3
import errno
import logging
import re


pageTemplate = Template('''
<!DOCTYPE HTML>
<html manifest="cache.manifest">
<head>
    <title>$title</title>
    <meta charset="utf-8" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width = device-width" />
$libraries
</head>

<body>
    <div id='header'>
        <ul class="pager">
            <li>
                <a href="index.html">Home</a>
            </li>
        </ul>
    </div>
      <div class="container-fluid label-warning">
          <h4>$title</h4>
      </div>
    <div id="content" class="container">
         <br/>
         $content
    </div>
    <br/>
    <div class="well well-sm">
        <small>$footer</small>
    </div>
</body>
</html>
''')

manifestTemplate = Template('''CACHE MANIFEST
# rev 1 -- this or the next comment must change with each new version to have browser get new cache
# Latest File Timestamp: $latest_file_timestamp; Date of conversion: $conversion_timestamp
$files
''')

indexTemplate = Template('''<!DOCTYPE HTML>
<html manifest="cache.manifest">
<head>
    <title>$entity ERP</title>
    <meta charset="utf-8" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
<!--meta name="viewport" content="initial-scale = 2" /-->
    <meta name="viewport" content="width = device-width" />
$libraries
</head>
<body>
    <article>
      <div class="container-fluid label-warning">
        <h4>$entity</h4>
      </div>

      <div class="list-group">
$links
      </div>            
    </article>
    <div class="well well-sm">
        <small>$footer</small>
    </div>
</body>
</html>''')

pageLinkTemplate = Template('<a href="$page" class="list-group-item">$pageName<span class="pull-right">&rarr;&nbsp;</span></a>')

def createPageFromFile(path, libraries):
    logging.info("processing input file: " + path)
    with open(path, "r") as f:
        doc = f.read().replace('\n', '')

    pagePattern = re.compile(r'.*?<span id="title-text">.*?:\s*(.*?)\s*</span>.*?<div id="main-content" class="wiki-content group">(.*?)</div>.*?<p>Document generated by Confluence on (.*?)</p>.*', re.DOTALL)
    pageMatch = pagePattern.match(doc)
    if pageMatch is None:
        logging.error("skipping " + path + " whose contents does not match expected format")
        logging.error(doc)
        return None
    d = dict(
             title=pageMatch.group(1), 
             content=pageMatch.group(2), 
             footer='Page generated on ' + pageMatch.group(3),
             libraries=getLibraryHtml(libraries)             
             )
    doc = pageTemplate.substitute(d)
    
    return doc.replace("confluence-embedded-image", "img-responsive")
    
def createIndexPageFromFile(path, libraries):
    logging.info("processing input index file: " + path)
    with open(path, "r") as f:
        doc = f.read().replace('\n', '')

    indexCompile = re.compile(r'.*?<th class="confluenceTh">Name</th>\s*?<td class="confluenceTd">(.*?)</td>(.*?)<p>Document generated by Confluence on (.*?)</p>.*', re.DOTALL)
    indexMatch = indexCompile.match(doc)
    if indexMatch is None:
        logging.error("skipping index " + path + " whose contents does not match expected format")
        logging.error(doc)
        return None
    
    pagesCompile = re.compile(r'<ul>\s*?<li>\s*?<a href="(.*?)">(.*?)</a>')
    pageLinks = []
    for (page, pageName) in re.findall(pagesCompile, indexMatch.group(2)):
        if keepFile(page):
            d = dict(page=page, pageName=pageName)
            pageLinks.append(pageLinkTemplate.substitute(d))
        
    d = dict(
             entity=indexMatch.group(1),
             links='\n'.join(pageLinks),
             footer='Page generated on ' + indexMatch.group(3),
             libraries=getLibraryHtml(libraries)
             )
    return indexTemplate.substitute(d)

def getEntityFromIndexFile(path):
    with open(path, "r") as f:
        doc = f.read().replace('\n', '')
    indexCompile = re.compile(r'.*?<th class="confluenceTh">Name</th>\s*?<td class="confluenceTd">(.*?)</td>.*', re.DOTALL)
    indexMatch = indexCompile.match(doc)
    if indexMatch is None:
        logging.error("cannot get entity from index " + path + " whose contents does not match expected format")
        logging.error(doc)
        return None
    return indexMatch.group(1)

def getLibraryFiles(path):
    return [ basename(f) for f in listdir(path) if isfile(join(path, f)) ]

def getLibraryHtml(files):
    html = ''
    for f in files:
        if f.endswith('.css'):
            html += '    <link rel="stylesheet" href="%s"/>\n' % f
        elif f.endswith('.js'):
            html += '    <script src="%s"></script>\n' % f            
        else:
            logging.error('only .css and .js libraries are supported; cannot ignoring %s' % f)
    return html

def keepFile(file_name):
    spaceHomeCompile = re.compile(r'.*?\-Home_.*?\.html', re.DOTALL)
    return spaceHomeCompile.match(file_name) is None

def isFileForApp(file_name):
    return isfile(file_name) and file_name.endswith('.html') and keepFile(file_name)

def createManifest(path, filenames, last_time):
    logging.info("creating manifest " + path)
    
    d = dict(
             files="\n".join(filenames),
             latest_file_timestamp=last_time,
             conversion_timestamp=strftime("%c")
             )
    
    return manifestTemplate.substitute(d)

class LocalFileWriter:
    def __init__(self, dest_dir, verbose=False):
        self.dest_dir = dest_dir

    def outputFile(self, dest_file_name, text, ignored=None):
        dest_path = join(self.dest_dir, dest_file_name)
        logging.info("writing file to: " + dest_path)
        dest_file = open(dest_path, "w")
        dest_file.write(text)
        dest_file.close()
        
    def copyDir(self, source_parent, dir_name):
        files = []
        source = join(source_parent, dir_name)
        dest = join(self.dest_dir, dir_name)
        logging.info("copying: " + source + " to: " + dest)
        try:
            rmtree(dest, ignore_errors=True)
            copytree(source, dest)
            # todo: add tree to files
        except OSError as e:
            # If the error was caused because the source wasn't a directory
            if e.errno == errno.ENOTDIR:
                rmtree(dest)
                copy(source, dest)
                files.append(dir_name)
            else:
                logging.error('Directory not copied. Error: %s' % e)
        return files
    
class S3Writer:
    def __init__(self, bucket_name):
        s3 = boto.connect_s3()
        self.bucket = s3.create_bucket(bucket_name, policy='public-read')
        self.bucket.configure_website('index.html')

    def outputFile(self, key_name, value, content_type='text/html'):
        logging.info('Writing key %s to Amazon S3 bucket %s' % (key_name, self.bucket.name))
        key = self.bucket.new_key(key_name)
        key.content_type = content_type
        key.set_contents_from_string(value, policy='public-read')
    
    def copyDir(self, source_parent, dir_name, follow_links = False):
#        islink, join, isdir = path.islink, path.join, path.isdir
        files = []
        curr_dir = join(source_parent, dir_name)
        try:
            names = listdir(curr_dir)
        except OSError as e:
            logging.error('Unable to list dir. Error: %s' % e)
            return

        dirs = []
        for name in names:
            sourcepath = join(curr_dir, name)
            destpath = join(dir_name, name)
            if isdir(sourcepath):
                dirs.append(destpath)
            else:
                logging.info('Uploading %s to Amazon S3 bucket %s' % (sourcepath, self.bucket.name))
                k = boto.s3.key.Key(self.bucket)
                k.key = destpath
                k.set_contents_from_filename(sourcepath, policy='public-read')
                files.append(destpath)

        for name in dirs:
            new_path = join(source_parent, name)
            if follow_links or not islink(new_path):  
                files += self.copyDir(source_parent, name, follow_links)
        
        return files
    
class MultiWriter:
    def __init__(self, writers):
        self.writers = writers
            
    def outputFile(self, key_name, value, content_type='text/html'):
        for writer in self.writers:
            writer.outputFile(key_name, value, content_type)
    
    def copyDir(self, source_parent, dir_name):
        files = []
        for writer in self.writers:
            files += writer.copyDir(source_parent, dir_name)
        return list(set(files))

def createSiteFromDir(source_dir, lib_dir, writer):
    writer.copyDir(lib_dir, '')
    lib_files = getLibraryFiles(lib_dir)
    
    # transform and move html files
    source_dir_list = [ join(source_dir, f) for f in listdir(source_dir)]
    source_files = [ f for f in source_dir_list if isFileForApp(f)]

#    source_files = [ f for f in listdir(source_dir) if isfile(join(source_dir, f)) ]
    html_file_list = []
    for file_name in source_files:
        logging.debug('found %s in source %s', file_name, source_dir)
        full_file_name = join(source_dir, file_name)
        file_name = basename(full_file_name)
        
        transformed = None
        if 'index.html' == file_name:
            transformed = createIndexPageFromFile(full_file_name, lib_files)
        else:
            transformed = createPageFromFile(full_file_name, lib_files)
            
        if not(transformed is None):
            html_file_list.append(file_name)
            writer.outputFile(file_name, transformed)
                    
    # copy the directories and their contents
    content_files = []
    for file_name in [ f for f in listdir(source_dir) if isdir(join(source_dir, f)) ]:
        content_files += writer.copyDir(source_dir, file_name)
        
    # write the manifest file
    latest_file_timestamp = max(iglob(source_dir + '*.html'), key=getctime)
    writer.outputFile(
               'cache.manifest',
               createManifest(
                              source_dir,
                              source_files + lib_files + content_files,
                              latest_file_timestamp
                              ),
               'text/cache-manifest'
               )

logging.basicConfig(level=logging.INFO)
parser = ArgumentParser(description='Process unzipped Confluence export source_dir and write to dest_dir')
parser.add_argument('source_dir', nargs=1)
parser.add_argument('lib_dir', nargs=1)
parser.add_argument('dest_dir', nargs=1)
args = parser.parse_args()
source_dir = args.source_dir[0]
lib_dir = args.lib_dir[0]
dest_dir = args.dest_dir[0]
bucket_name = getEntityFromIndexFile(join(source_dir, 'index.html')).lower().replace(' ', '')
writer = MultiWriter(
                     [
                      LocalFileWriter(dest_dir),
                      S3Writer(bucket_name)
                      ]
                     )

createSiteFromDir(source_dir, lib_dir, writer)
